<!doctype html>
<html>
  <head>
    <link rel=icon type="image/png" href="favicon.png">
    <meta name="twitter:image:src" content="https://metacomposer.com/logo.svg">
    <meta name="twitter:site" content="@exokitxr">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Metacomposer">
    <meta name="twitter:description" content="Meta composer">
    <meta property="og:title" content="Metacomposer">
    <meta property="og:type" content="referenceSpace">
    <meta property="og:url" content="https://metacomposer.com/">
    <meta property="og:image" content="https://metacomposer.com/logo.svg">
    <link href="index.css" rel=stylesheet>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/0735724151.js" crossorigin="anonymous"></script>
    <!-- <script type="module" src="world.js"></script> -->
    <script src="https://rawcdn.githack.com/ethereum/web3.js/a6ddec59e65116853435f203b25cb9c55824d084/dist/web3.min.js"></script>
  </head>
  <body>
    <header>
      <!-- <a href="https://browser.exokit.org">
        <img class=icon src="logo.svg"/>
      </a> -->
      <a href="/" class="nav open" id="explore-dropdown">Webaverse Composer</a>
      <!-- <a href="/world.html" class="nav" id="explore-dropdown">Atlas</a>
      <a href="/create.html" class="nav" id="explore-dropdown">Create</a>
      <a href="/gallery.html" class="nav" id="explore-dropdown">Gallery</a> -->
    </header>
    <canvas id=canvas></canvas>
    <div class=top-right>
      <div class="sidebar-icon {{#hidePrefabs}}hidden{{/hidePrefabs}}" id=prefabs-button>
        <i class="fa fa-arrow-left"></i>
        <i class="fa fa-arrow-right open"></i>
        <div class=label>Backpack</div>
      </div>
      <div class="content prefabs-content hidden" id=prefabs-content>
        <input type=text placeholder="Find an item..." id=prefabs-search>
        <div class=end></div>
      </div>
    </div>
<script type=module>
import THREE from './three.module.js';
import {OrbitControls} from './OrbitControls.js';
import {GLTFLoader} from './GLTFLoader.js';
import {LegacyGLTFLoader} from './LegacyGLTFLoader.js';
import {OBJLoader2} from './OBJLoader2.js';
import {MTLLoader} from './MTLLoader.js';
import {GLTFExporter} from './GLTFExporter.js';
import {BufferGeometryUtils} from './BufferGeometryUtils.js';
import {makePromise, Mesher} from './mesher.js';
import modelFiles from './model-files.js';
import BezierEasing from './cubic-bezier.js';
import {OutlineEffect} from './OutlineEffect.js';
import {XRPackageEngine, XRPackage} from './xrpackage.js';
import address from 'https://contracts.webaverse.com/address.js';
import abi from 'https://contracts.webaverse.com/abi.js';

(async () => {

{
  await navigator.serviceWorker.register('/sw.js', {
    // type: 'module',
  });
  if (!navigator.serviceWorker.controller) {
    await new Promise((accept, reject) => {
      const _controllerchange = () => {
        if (navigator.serviceWorker.controller) {
          navigator.serviceWorker.removeEventListener('controllerchange', _controllerchange);
          clearTimeout(timeout);
          accept();
        }
      };
      navigator.serviceWorker.addEventListener('controllerchange', _controllerchange);
      const timeout = setTimeout(() => {
        console.warn('sw registration timed out');
        debugger;
      }, 10 * 1000);
    });
  }
  console.log('got registration', window.registration);
}
const _requestSw = (m = {}, txs = []) => new Promise((accept, reject) => {
  const mc = new MessageChannel();
  txs.push(mc.port2);
  navigator.serviceWorker.controller.postMessage(m, txs);
  mc.port1.onmessage = () => {
    accept();
  };
});

const apiHost = `https://ipfs.exokit.org/ipfs`;
const network = 'rinkeby';
const infuraApiKey = '4fb939301ec543a0969f3019d74f80c2';
const rpcUrl = `https://${network}.infura.io/v3/${infuraApiKey}`;
const web3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));
const contract = new web3.eth.Contract(abi, address);

const easing = BezierEasing(0, 1, 0, 1);

const _escapeRegExp = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

const pe = new XRPackageEngine();
document.body.appendChild(pe.domElement);

const renderer = new THREE.WebGLRenderer({
  canvas: pe.domElement,
  context: pe.getContext('webgl'),
  // alpha: true,
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.autoClear = false;
renderer.sortObjects = false;
renderer.physicallyCorrectLights = true;
renderer.xr.enabled = true;
// renderer.shadowMap.enabled = true;
// renderer.shadowMap.type = THREE.PCFShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 1, 1.5);
camera.rotation.order = 'YXZ';
renderer.render(scene, camera);

// window.renderer = renderer;

const ambientLight = new THREE.AmbientLight(0xFFFFFF);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight.position.set(0.5, 1, 0.5).multiplyScalar(100);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 500;
scene.add(directionalLight);

const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight2.position.set(-0.5, -0.1, 0.5).multiplyScalar(100);
scene.add(directionalLight2);

const container = new THREE.Object3D();
scene.add(container);

const orbitControls = new OrbitControls(camera, renderer.domElement, document);
orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5));
orbitControls.screenSpacePanning = true;
// orbitControls.enabled = !!loginToken;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const hoverOutlineEffect = new OutlineEffect(renderer, {
  defaultThickness: 0.01,
  defaultColor: new THREE.Color(0x42a5f5).toArray(),
  defaultAlpha: 0.5,
  // defaultKeepAlive: false,//true,
});
const selectOutlineEffect = new OutlineEffect(renderer, {
  defaultThickness: 0.01,
  defaultColor: new THREE.Color(0x66bb6a).toArray(),
  defaultAlpha: 0.5,
  // defaultKeepAlive: false,//true,
});
const outlineScene = new THREE.Scene();
let hoveredObjectMesh = null;
let selectedObjectMesh = null;
let renderingOutline = false;
scene.onAfterRender = () => {
  if (renderingOutline) return;
  renderingOutline = true;

  outlineScene.position.copy(container.position);
  outlineScene.quaternion.copy(container.quaternion);
  outlineScene.scale.copy(container.scale);

  let oldHoverParent;
  if (hoveredObjectMesh) {
    oldHoverParent = hoveredObjectMesh.parent;
    outlineScene.add(hoveredObjectMesh);
  }
  hoverOutlineEffect.renderOutline(outlineScene, camera);
  if (oldHoverParent) {
    oldHoverParent.add(hoveredObjectMesh);
  }

  let oldSelectParent;
  if (selectedObjectMesh) {
    oldSelectParent = selectedObjectMesh.parent;
    outlineScene.add(selectedObjectMesh);
  }
  selectOutlineEffect.renderOutline(outlineScene, camera);
  if (oldSelectParent) {
    oldSelectParent.add(selectedObjectMesh);
  }

  renderingOutline = false;
};
renderer.domElement.addEventListener('dblclick', async e => {
  await renderer.domElement.requestPointerLock();
});
const keys = {
  up: false,
  down: false,
  left: false,
  right: false,
  shift: false,
};
const localRaycaster = new THREE.Raycaster();
const _updateRaycasterFromMouseEvent = (raycaster, e) => {
  const mouse = new THREE.Vector2(( ( e.clientX ) / window.innerWidth ) * 2 - 1, - ( ( e.clientY ) / window.innerHeight ) * 2 + 1);
  raycaster.setFromCamera(mouse, camera);
  raycaster.ray.origin.add(raycaster.ray.direction);
};
let raycasting = false;
[renderer.domElement].forEach(w => {
  w.addEventListener('keydown', e => {
    switch (e.which) {
      case 87: { // W
        if (!document.pointerLockElement) {
          /* selectedObjectMeshes.forEach(selectedObjectMesh => {
            selectedObjectMesh.control.setMode('translate');
          }); */
        } else {
          keys.up = true;
        }
        break;
      }
      case 65: { // A
        if (!document.pointerLockElement) {
          /* selectedObjectMeshes.forEach(selectedObjectMesh => {
            selectedObjectMesh.control.setMode('translate');
          }); */
        } else {
          keys.left = true;
        }
        break;
      }
      case 83: { // S
        if (!document.pointerLockElement) {
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            e.stopPropagation();

            interfaceDocument.getElementById('save-op').click();
          }
        } else {
          keys.down = true;
        }
        break;
      }
      case 68: { // D
        if (!document.pointerLockElement) {
          // nothing
        } else {
          keys.right = true;
        }
        break;
      }
      case 16: { // shift
        if (document.pointerLockElement) {
          keys.shift = true;
        }
        break;
      }
    }
  });
  w.addEventListener('keyup', e => {
    switch (e.which) {
      case 87: { // W
        if (document.pointerLockElement) {
          keys.up = false;
        }
        break;
      }
      case 65: { // A
        if (document.pointerLockElement) {
          keys.left = false;
        }
        break;
      }
      case 83: { // S
        if (document.pointerLockElement) {
          keys.down = false;
        }
        break;
      }
      case 68: { // D
        if (document.pointerLockElement) {
          keys.right = false;
        }
        break;
      }
      case 16: { // shift
        if (document.pointerLockElement) {
          keys.shift = false;
        }
        break;
      }
    }
  });
  w.addEventListener('mousemove', async e => {
    if (!document.pointerLockElement) {
      if (!raycasting) {
        raycasting = true;
        _updateRaycasterFromMouseEvent(localRaycaster, e);
        const res = await mesher.intersectMeshes(localRaycaster.ray.origin.toArray(), localRaycaster.ray.direction.toArray());
        const {id} = res;
        if (id) {
          hoveredObjectMesh = meshes.find(m => m.meshId === id) || null;
        } else {
          hoveredObjectMesh = null;
        }
        raycasting = false;
      }
    } else {
      const {movementX, movementY} = e;
      camera.rotation.y -= movementX * Math.PI*2*0.001;
      camera.rotation.x -= movementY * Math.PI*2*0.001;
    }
  });
  w.addEventListener('mousedown', e => {
    selectedObjectMesh = hoveredObjectMesh;
  });
});

function mod(a, n) {
  return ((a%n)+n)%n;
}
const distanceFactor = 64;
const parcelSize = 16;
const parcelGeometry = (() => {
  const tileGeometry = new THREE.PlaneBufferGeometry(1, 1)
    .applyMatrix4(new THREE.Matrix4().makeScale(0.95, 0.95, 1))
    .applyMatrix4(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2)))
    .toNonIndexed();
  const numCoords = tileGeometry.attributes.position.array.length;
  const numVerts = numCoords/3;
  const positions = new Float32Array(numCoords*parcelSize*parcelSize);
  const centers = new Float32Array(numCoords*parcelSize*parcelSize);
  const typesx = new Float32Array(numVerts*parcelSize*parcelSize);
  const typesz = new Float32Array(numVerts*parcelSize*parcelSize);
  let i = 0;
  for (let x = -parcelSize/2+0.5; x < parcelSize/2; x++) {
    for (let z = -parcelSize/2+0.5; z < parcelSize/2; z++) {
      const newTileGeometry = tileGeometry.clone()
        .applyMatrix4(new THREE.Matrix4().makeTranslation(x, 0, z));
      positions.set(newTileGeometry.attributes.position.array, i * newTileGeometry.attributes.position.array.length);
      for (let j = 0; j < newTileGeometry.attributes.position.array.length/3; j++) {
        new THREE.Vector3(x, 0, z).toArray(centers, i*newTileGeometry.attributes.position.array.length + j*3);
      }
      let typex = 0;
      if (mod((x + parcelSize/2-0.5), parcelSize) === 0) {
        typex = 1/8;
      } else if (mod((x + parcelSize/2-0.5), parcelSize) === parcelSize-1) {
        typex = 2/8;
      }
      let typez = 0;
      if (mod((z + parcelSize/2-0.5), parcelSize) === 0) {
        typez = 1/8;
      } else if (mod((z + parcelSize/2-0.5), parcelSize) === parcelSize-1) {
        typez = 2/8;
      }
      for (let j = 0; j < numVerts; j++) {
        typesx[i*numVerts + j] = typex;
        typesz[i*numVerts + j] = typez;
      }
      i++;
    }
  }
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('center', new THREE.BufferAttribute(centers, 3));
  geometry.setAttribute('typex', new THREE.BufferAttribute(typesx, 1));
  geometry.setAttribute('typez', new THREE.BufferAttribute(typesz, 1));
  return geometry;
})();
const floorVsh = `
  #define PI 3.1415926535897932384626433832795

  uniform vec3 uPosition;
  uniform float uAnimation;
  uniform vec4 uSelectedParcel;
  attribute vec3 center;
  attribute float typex;
  attribute float typez;
  varying vec3 vPosition;
  varying float vTypex;
  varying float vTypez;
  varying float vDepth;
  varying float vPulse;

  float range = 1.0;

  void main() {
    float height;
    vec3 c = center + uPosition;
    float selectedWidth = uSelectedParcel.z - uSelectedParcel.x;
    float selectedHeight = uSelectedParcel.w - uSelectedParcel.y;
    if (c.x >= uSelectedParcel.x && c.x < uSelectedParcel.z && c.z >= uSelectedParcel.y && c.z < uSelectedParcel.w) {
      vec2 selectedCenter = vec2((uSelectedParcel.x+uSelectedParcel.z) / 2.0, (uSelectedParcel.y+uSelectedParcel.w) / 2.0);
      float selectedSize = max(selectedWidth, selectedHeight)/2.0;
      float selectedRadius = sqrt(selectedSize*selectedSize+selectedSize*selectedSize);

      float animationRadius = uAnimation * selectedRadius;
      float currentRadius = length(c.xz - selectedCenter);
      float radiusDiff = abs(animationRadius - currentRadius);
      height = max((range - radiusDiff)/range, 0.0);
      height = sin(height*PI/2.0);
      height *= 0.2;

      vPulse = 1.0 + (1.0 - mod(uAnimation * 2.0, 1.0)/2.0) * 0.5;
    } else {
      vPulse = 1.0;
    }
    vec3 p = vec3(position.x, position.y + height, position.z);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
    vPosition = position;
    vTypex = typex;
    vTypez = typez;
    vDepth = gl_Position.z / ${distanceFactor.toFixed(8)};
  }
`;
const floorFsh = `
  #define PI 3.1415926535897932384626433832795

  uniform vec3 uColor;
  uniform float uHover;
  uniform float uAnimation;
  varying vec3 vPosition;
  varying float vTypex;
  varying float vTypez;
  varying float vDepth;
  varying float vPulse;

  void main() {
    float add = uHover * 0.2;
    vec3 f = fract(vPosition);
    if (vTypex >= 2.0/8.0) {
      if (f.x >= 0.8) {
        add = 0.2;
      }
    } else if (vTypex >= 1.0/8.0) {
      if (f.x <= 0.2) {
        add = 0.2;
      }
    }
    if (vTypez >= 2.0/8.0) {
      if (f.z >= 0.8) {
        add = 0.2;
      }
    } else if (vTypez >= 1.0/8.0) {
      if (f.z <= 0.2) {
        add = 0.2;
      }
    }
    vec3 c = (uColor + add) * vPulse;
    float a = (1.0-vDepth)*0.8;
    gl_FragColor = vec4(c, a);
  }
`;
const _makeFloorMesh = (x, z) => {
  const geometry = parcelGeometry;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uPosition: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uColor: {
        type: 'c',
        value: new THREE.Color().setHex(0x333333),
      },
      uHover: {
        type: 'f',
        value: 0,
      },
      uSelectedParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: floorVsh,
    fragmentShader: floorFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  // mesh.position.set(x*parcelSize, 0, z*parcelSize);
  // mesh.material.uniforms.uPosition.value.copy(mesh.position);
  mesh.frustumCulled = false;
  /* mesh.update = () => {
    const xrSite = _getFloorMeshXrSite(mesh);
    const color = _getSelectedColor(xrSite);
    material.uniforms.uColor.value.setHex(color);
  }; */
  return mesh;
};
const floorMesh = _makeFloorMesh();
container.add(floorMesh);

const wallGeometry = (() => {
  const panelGeometries = [];
  for (let x = 0; x <= 1; x++) {
    panelGeometries.push(
      new THREE.BoxBufferGeometry(0.01, 2, 0.01)
        .applyMatrix4(new THREE.Matrix4().makeTranslation(x, 1, 0))
    );
  }
  for (let h = 0; h <= 2; h++) {
    panelGeometries.push(
      new THREE.BoxBufferGeometry(1, 0.01, 0.01)
        .applyMatrix4(new THREE.Matrix4().makeTranslation(0.5, h, 0))
    );
  }
  return BufferGeometryUtils.mergeBufferGeometries(panelGeometries);
})();
const topWallGeometry = wallGeometry.clone()
  // .applyMatrix4(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5));
const leftWallGeometry = wallGeometry.clone()
  .applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), Math.PI/2))
  // .applyMatrix4(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5));
const rightWallGeometry = wallGeometry.clone()
  .applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), -Math.PI/2))
  // .applyMatrix4(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5));
const bottomWallGeometry = wallGeometry.clone()
  .applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0, 1, 0), Math.PI))
  // .applyMatrix4(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5));
const floorGeometry = new THREE.PlaneBufferGeometry(1, 1)
  .applyMatrix4(new THREE.Matrix4().makeScale(0.99, 0.99, 1))
  .applyMatrix4(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0.01))
  .applyMatrix4(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), -Math.PI/2));
const gridVsh = `
  // varying vec3 vWorldPos;
  // varying vec2 vUv;
  uniform float uStart;
  varying float vDepth;
  void main() {
    vec3 p = position;
    p.y *= uStart;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
    // vUv = uv;
    // vWorldPos = abs(position);
    vDepth = gl_Position.z / ${distanceFactor.toFixed(8)};
  }
`;
const gridFsh = `
  // uniform sampler2D uTex;
  uniform vec3 uColor;
  uniform float uFlash;
  uniform float uStart;
  // varying vec3 vWorldPos;
  varying float vDepth;
  void main() {
    float f = uFlash*0.5;
    vec3 c = uColor*(1.0-f) + f;
    float a = (1.0-vDepth)*uStart*0.3;
    gl_FragColor = vec4(c, a);
  }
`;
const _makeParcelMesh = (extents, color, key) => {
  const [[ax1, ay1, ax2, ay2]] = extents;
  const w = ax2 - ax1;
  const h = ay2 - ay1;
  const geometry = (() => {
    const geometries = [];
    geometries.push(
      floorGeometry.clone()
        // .applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, 1))
        .applyMatrix4(new THREE.Matrix4().makeScale(w, 1, h))
        .applyMatrix4(new THREE.Matrix4().makeTranslation(ax1, 0, ay1))
    );
    for (let x = ax1; x < ax2; x++) {
      geometries.push(
        topWallGeometry.clone()
          .applyMatrix4(new THREE.Matrix4().makeTranslation(x, 0, ay1))
      );
      geometries.push(
        bottomWallGeometry.clone()
          .applyMatrix4(new THREE.Matrix4().makeTranslation(x+1, 0, ay2))
      );
    }
    for (let y = ay1; y < ay2; y++) {
      geometries.push(
        leftWallGeometry.clone()
          .applyMatrix4(new THREE.Matrix4().makeTranslation(ax1, 0, y+1))
      );
      geometries.push(
        rightWallGeometry.clone()
          .applyMatrix4(new THREE.Matrix4().makeTranslation(ax2, 0, y))
      );
    }
    return BufferGeometryUtils.mergeBufferGeometries(geometries);
  })();
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uColor: {
        type: 'c',
        value: new THREE.Color(color),
      },
      uStart: {
        type: 'f',
        value: 0,
      },
      uFlash: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: gridVsh,
    fragmentShader: gridFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.aabb = new THREE.Box3(
    new THREE.Vector3(ax1, 0, ay1),
    new THREE.Vector3(ax2, 128, ay2)
  );
  mesh.key = key;
  mesh.startTime = Date.now();
  /* mesh.setColor = c => {
    mesh.material.uniforms.uColor.value.setHex(c);
  }; */
  mesh.frustumCulled = false;

  const chunk = mesher.getChunk(mesh.aabb);
  /* chunk.addEventListener('previewMesh', e => {
    const {previewMesh: pm} = e.data;
    mesh.add(pm);
  });
  chunk.addEventListener('mesh', e => {
    const {mesh: m, previewMesh: pm} = e.data;
    mesh.remove(pm);
    mesh.add(m);
  }); */
  mesh.destroy = () => {
    chunk.destroy();
  };

  return mesh;
};
const parcels = {};
let parcelMeshes = [];
const _loadParcelMeshes = p => {
  const currentParcels = {};
  let cx = Math.floor(p.x/8);
  let cz = Math.floor(p.z/8);
  for (let dx = -1; dx <= 1; dx++) {
    for (let dz = -1; dz <= 1; dz++) {
      const ax = cx+dx;
      const az = cz+dz;
      const k = ax + ':' + az;
      if (!parcels[k]) {
        const parcelMesh = _makeParcelMesh([[ax*8, az*8, ax*8+8, az*8+8]], 0x66bb6a, k);
        container.add(parcelMesh);
        parcelMeshes.push(parcelMesh);
        parcels[k] = true;
      }
      currentParcels[k] = true;
    }
  }
  parcelMeshes = parcelMeshes.filter(parcelMesh => {
    const {key} = parcelMesh;
    if (currentParcels[key]) {
      return true;
    } else {
      parcelMesh.destroy();
      container.remove(parcelMesh);
      parcels[key] = false;
      return false;
    }
  });
};

const mesher = new Mesher(renderer, scene, camera);
const meshes = [];
mesher.addEventListener('previewMesh', e => {
  const {previewMesh} = e.data;

  container.add(previewMesh);

  meshes.push(previewMesh);
});
mesher.addEventListener('mesh', e => {
  const {mesh, previewMesh} = e.data;

  container.remove(previewMesh);
  container.add(mesh);

  meshes.splice(meshes.indexOf(previewMesh), 1);
  meshes.push(mesh);

  (hoveredObjectMesh === previewMesh) && (hoveredObjectMesh = null);
  (selectedObjectMesh === previewMesh) && (selectedObjectMesh = null);
});
mesher.addEventListener('removeMesh', e => {
  const {mesh, previewMesh} = e.data;

  mesh && container.remove(mesh);
  previewMesh && container.remove(previewMesh);

  mesh && meshes.splice(meshes.indexOf(mesh), 1);
  previewMesh && meshes.splice(meshes.indexOf(previewMesh), 1);

  (hoveredObjectMesh === mesh) && (hoveredObjectMesh = null);
  (hoveredObjectMesh === previewMesh) && (hoveredObjectMesh = null);
  (selectedObjectMesh === mesh) && (selectedObjectMesh = null);
  (selectedObjectMesh === previewMesh) && (selectedObjectMesh = null);
});
(async () => {
  // const manager = new THREE.LoadingManager();

  const _getMeshUrl = (x, z) => `/d/chunk:${x}:${z}.bin`;
  /* const _serializeRawMesh = async mesh => {
    const positions = mesh.geometry.attributes.position.array;
    const normals = mesh.geometry.attributes.normal.array;
    const colors = mesh.geometry.attributes.color.array;
    const uvs = mesh.geometry.attributes.uv.array;
    const ids = mesh.geometry.attributes.id.array;
    const texData = await new Promise((accept, reject) => {
      mesh.material.map.image.toBlob(b => {
        const rs = new FileReader();
        rs.onload = () => accept(new Uint8Array(rs.result));
        rs.onerror = reject;
        rs.readAsArrayBuffer(b);
      });
    });

    const arrayBuffer = new ArrayBuffer(
      Uint32Array.BYTES_PER_ELEMENT +
      positions.length*Float32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      normals.length*Float32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      colors.length*Float32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      uvs.length*Float32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      ids.length*Uint32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      texData.length
    );

    let index = 0;
    const _set = o => {
      new Uint32Array(arrayBuffer, index, 1)[0] = o.length;
      index += Uint32Array.BYTES_PER_ELEMENT;
      new o.constructor(arrayBuffer, index, o.length).set(o);
      index += o.length*o.constructor.BYTES_PER_ELEMENT;
    };
    _set(positions);
    _set(normals);
    _set(colors);
    _set(uvs);
    _set(ids);
    _set(texData);

    return arrayBuffer;
  };
  const _deserializeRawMesh = async arrayBuffer => {
    let index = 0;
    const _get = c => {
      const count = new Uint32Array(arrayBuffer, index, 1)[0];
      index += Uint32Array.BYTES_PER_ELEMENT;
      const o = new c(arrayBuffer, index, count);
      index += count*c.BYTES_PER_ELEMENT;
      return o;
    };
    const positions = _get(Float32Array);
    const normals = _get(Float32Array);
    const colors = _get(Float32Array);
    const uvs = _get(Float32Array);
    const ids = _get(Uint32Array);
    const texData = _get(Uint8Array);

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    geometry.setAttribute('id', new THREE.BufferAttribute(ids, 1));

    const material = makeGlobalMaterial();
    const img = await new Promise((accept, reject) => {
      const img = new Image();
      const u = URL.createObjectURL(new Blob([texData], {
        type: 'image/png',
      }));
      img.src = u;
      img.onload = () => {
        URL.revokeObjectURL(u);
        accept(img);
      };
      img.onerror = err => {
        URL.revokeObjectURL(u);
        reject(err);
      };
    });
    material.map = makeTexture(img);

    const mesh = new THREE.Mesh(geometry, material);
    mesh.frustumCulled = false;
    return mesh;
  }; */

  /* meshes = await (async () => {
    const result = [];
    for (let x = -1; x < 1; x++) {
      for (let z = -1; z < 1; z++) {
        const res = await fetch(_getMeshUrl(x, z));
        const arrayBuffer = await res.arrayBuffer();
        const mesh = await _deserializeMesh(arrayBuffer);
        meshes.push(mesh);
      }
    }
    return result;
  })(); */

  (async () => {
    const objs = modelFiles.filter(m => /\.obj/.test(m));
    const rowSize = 10;
    const numItems = 10;
    for (let i = 0; i < numItems; i++) {
      const u = `models/${objs[i]}`;
      const x = -rowSize/2 + i%rowSize;
      const z = -Math.floor(i/rowSize);
      mesher.addMesh(u, new THREE.Vector3(x, 0, z));
    }
  })();

  /* {
    const p = makePromise();
    new GLTFLoader(manager).load('models/mountain.glb', p.accept, function onProgress() {}, p.reject);
    const o = await p;
    mesher.addMesh(o.scene, new THREE.Vector3(0, 0, -30));
  } */

  /* {
    const p = makePromise();
    new GLTFLoader(manager).load('models/building.glb', p.accept, function onProgress() {}, p.reject);
    const o = await p;
    const mesh = await mesher.voxelize(o.scene);
    container.add(mesh);
  } */

  {
    mesher.addMesh('models/model.vrm');
  }

  /* {
    const p = makePromise();
    new LegacyGLTFLoader(manager).load('models/dino/sketch.gltf', p.accept, function onProgress() {}, p.reject);
    const o = await p;
    mesher.addMesh(o.scene);
  } */

  /* {
    const p = makePromise();
    new GLTFLoader(manager).load('models/scene.glb', p.accept, function onProgress() {}, p.reject);
    const o = await p;

    // window.o = o;
    // o.scene.children.splice(40, Infinity);
    // const chair = o.scene.children.slice(29, 30);
    // o.scene.children.length = 0;
    // o.scene.children.push.apply(o.scene.children, chair);
    _mergeScene(o.scene);

    // container.add(o.scene);
  } */

  return;

  {
    for (let i = 0; i < meshes.length; i++) {
      const mesh = meshes[i];
      const body = await _serializeRawMesh(mesh);
      const res = await fetch(_getMeshUrl(x, z), {
        method: 'PUT',
        body,
      });
      if (!res.ok) {
        throw new Error(`got invalid status code: ${res.status}`);
      }
    }
  }
})();

const prefabsButton = document.getElementById('prefabs-button');
const prefabsContent = document.getElementById('prefabs-content');
const prefabsSearch = document.getElementById('prefabs-search');
const prefabsContentEnd = document.querySelector('.end');
prefabsButton.addEventListener('click', e => {
  prefabsButton.classList.toggle('hidden');
  prefabsContent.classList.toggle('hidden');
});
async function getObjectByIndex(index) {
  const metadataHash = await contract.methods.getMetadata(index, 'hash').call();
  const metadata = await fetch(`${apiHost}/${metadataHash}`).then(res => res.json());
  const {dataHash, screenshotHash, modelHash} = metadata;
  return {
    name: metadata.objectName,
    img: `${apiHost}/${screenshotHash}.png`,
    model: `${apiHost}/${modelHash}.glb`,
  }
}
(async () => {
  let totalObjects = await contract.methods.getNonce().call();
  totalObjects = parseInt(totalObjects, 10);

  for (let i = 1; i <= totalObjects; i++) {
    const object = await getObjectByIndex(i);
    const {name, img, model} = object;

    const aPrefab = document.createElement('nav');
    aPrefab.classList.add('a-prefab');
    aPrefab.setAttribute('draggable', 'true');
    aPrefab.setAttribute('src', encodeURI(img));
    aPrefab.setAttribute('name', name);
    aPrefab.innerHTML = `<div class=overlay>
      <div class=multibutton>
        <nav class="button first last add-button">Add</nav>
      </div>
    </div>
    <img src="${encodeURI(img)}" width=80 height=80>
    <div class=wrap>
      <div class=label>${name}</div>
    </div>`;

    aPrefab.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text', JSON.stringify({
        type: 'model',
        name: `${name}.glb`,
        src: model,
      }));
    });
    const addButton = aPrefab.querySelector('.add-button');
    addButton.addEventListener('click', () => {
      console.log('got click');
      /* const dom = parseHtml(codeInput.value);
      const xrSite = landConnection ? _findNodeWithTagNameAttributes(dom, 'xr-site', [{name: 'edit', value: 'true'}]) : _findNodeWithTagName(dom, 'xr-site');
      if (xrSite) {
        const position = localVector.copy(camera.position)
          .divide(container.scale)
          .add(new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion));
        position.y = 0;
        xrSite.childNodes.push(parseHtml(`<xr-model src="${encodeURI(src)}" position="${position.toArray().join(' ')}"></xr-model>`).childNodes[0]);
        codeInput.value = serializeHtml(dom);
        codeInput.dispatchEvent(new CustomEvent('change'));
      } else {
        console.warn('no xr-site to add to');
      } */
    });

    prefabsContent.insertBefore(aPrefab, prefabsContentEnd);
  }
})();
prefabsSearch.addEventListener('input', e => {
  const regex = new RegExp(_escapeRegExp(e.target.value), 'i');
  const prefabs = Array.from(prefabsContent.querySelectorAll('nav'));
  const prefabSearchResults = prefabs.filter(prefab => regex.test(prefab.getAttribute('name')));
  prefabs.forEach(prefab => {
    prefab.classList.add('hidden');
  });
  prefabSearchResults.forEach(prefab => {
    prefab.classList.remove('hidden');
  });
});
document.addEventListener('dragover', e => {
  e.preventDefault();
});
document.addEventListener('drop', async e => {
  e.preventDefault();

  if (e.dataTransfer.items.length > 0) {
    const item = e.dataTransfer.items[0];
    /* if (item.kind === 'file') {
      await _handleUpload(item.getAsFile());
    } else */if (item.kind === 'string') {
      const data = await new Promise((accept, reject) => {
        item.getAsString(accept);
      });
      const j = (() => {
        try {
          return JSON.parse(data);
        } catch(err) {
          return null;
        }
      })();
      if (j !== null) {
        const {name, src} = j;
        const res = await fetch(src);
        const blob = await res.blob();
        blob.name = name;
        const d = await XRPackage.compileFromFile(blob);
        const p = new XRPackage(d);
        await pe.add(p);
        p.setMatrix(new THREE.Matrix4().compose(
          camera.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion)),
          camera.quaternion,
          new THREE.Vector3(1, 1, 1)
        ));
      }
    }
  }
});

const velocity = new THREE.Vector3();
function animate() {
  renderer.state.reset();

  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);
renderer.xr.setSession(pe.fakeSession);

pe.addEventListener('tick', () => {
  const speed = 0.015 * (keys.shift ? 3 : 1);
  const cameraEuler = camera.rotation.clone();
  cameraEuler.x = 0;
  cameraEuler.z = 0;
  const extraVelocity = new THREE.Vector3();
  if (keys.left) {
    extraVelocity.add(new THREE.Vector3(-1, 0, 0).applyEuler(cameraEuler));
  }
  if (keys.right) {
    extraVelocity.add(new THREE.Vector3(1, 0, 0).applyEuler(cameraEuler));
  }
  if (keys.up) {
    extraVelocity.add(new THREE.Vector3(0, 0, -1).applyEuler(cameraEuler));
  }
  if (keys.down) {
    extraVelocity.add(new THREE.Vector3(0, 0, 1).applyEuler(cameraEuler));
  }
  if (extraVelocity.length() > 0) {
    extraVelocity.normalize().multiplyScalar(speed);
  }
  velocity.add(extraVelocity);
  camera.position.add(velocity);
  velocity.multiplyScalar(0.7);

  orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -3).applyQuaternion(camera.quaternion));

  if (orbitControls.enabled && !document.pointerLockElement) {
    orbitControls.update();
  }

  pe.setCamera(camera);

  _loadParcelMeshes(orbitControls.target);
  parcelMeshes.forEach(parcelMesh => {
    parcelMesh.material.uniforms.uFlash.value = 1-((Date.now() - parcelMesh.startTime) % 1000)/1000;
    parcelMesh.material.uniforms.uStart.value = Math.min(easing((Date.now() - parcelMesh.startTime)/2000), 1);
  });
});

window.addEventListener('resize', e => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});

})();
</script>
  </body>
</html>