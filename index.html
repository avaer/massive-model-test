<!doctype html>
<html>
  <head>
    <link rel=icon type="image/png" href="favicon.png">
    <meta name="twitter:image:src" content="https://metacomposer.com/logo.svg">
    <meta name="twitter:site" content="@exokitxr">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Metacomposer">
    <meta name="twitter:description" content="Meta composer">
    <meta property="og:title" content="Metacomposer">
    <meta property="og:type" content="referenceSpace">
    <meta property="og:url" content="https://metacomposer.com/">
    <meta property="og:image" content="https://metacomposer.com/logo.svg">
    <link href="index.css" rel=stylesheet>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/0735724151.js" crossorigin="anonymous"></script>
    <!-- <script type="module" src="world.js"></script> -->
  </head>
  <body>
    <header>
      <!-- <a href="https://browser.exokit.org">
        <img class=icon src="logo.svg"/>
      </a> -->
      <a href="/" class="nav open" id="explore-dropdown">Test</a>
      <!-- <a href="/world.html" class="nav" id="explore-dropdown">Atlas</a>
      <a href="/create.html" class="nav" id="explore-dropdown">Create</a>
      <a href="/gallery.html" class="nav" id="explore-dropdown">Gallery</a> -->
    </header>
    <canvas id=canvas></canvas>
<script type=module>
import THREE from './three.module.js';
import {OrbitControls} from './OrbitControls.js';
import {GLTFLoader} from './GLTFLoader.js';
import {OBJLoader2} from './OBJLoader2.js';
import {MTLLoader} from './MTLLoader.js';
import atlaspack from './atlaspack.js';
import modelFiles from './model-files.js';

Error.stackTraceLimit = 300;

function makePromise() {
  let accept, reject;
  const p = new Promise((a, r) => {
    accept = a;
    reject = r;
  });
  p.accept = accept;
  p.reject = reject;
  return p;
}
function mod(a, b) {
  return ((a%b)+b)%b;
}
const _makeWasmWorker = () => {
  let cbs = [];
  const w = new Worker('mc-worker.js');
  w.onmessage = e => {
    const {data} = e;
    const {error, result} = data;
    cbs.shift()(error, result);
  };
  w.onerror = err => {
    console.warn(err);
  };
  w.request = (req, transfers) => new Promise((accept, reject) => {
    w.postMessage(req, transfers);

    cbs.push((err, result) => {
      if (!err) {
        accept(result);
      } else {
        reject(err);
      }
    });
  });
  return w;
};

const canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true,
});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
renderer.physicallyCorrectLights = true;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xEEEEEE);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0.5, 1.5);
camera.rotation.order = 'YXZ';
renderer.render(scene, camera);

// window.renderer = renderer;

const ambientLight = new THREE.AmbientLight(0xFFFFFF);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight.position.set(0.5, 1, 0.5).multiplyScalar(100);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 500;
scene.add(directionalLight);

const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight2.position.set(-0.5, -0.1, 0.5).multiplyScalar(100);
scene.add(directionalLight2);

const container = new THREE.Object3D();
scene.add(container);

const orbitControls = new OrbitControls(camera, renderer.domElement, document);
orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5));
orbitControls.screenSpacePanning = true;
// orbitControls.enabled = !!loginToken;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const worker = _makeWasmWorker();

const meshes = [];
(async () => {
  const NUM_POSITIONS = 2 * 1024 * 1024;
  let currentMesh = null;
  let atlas = null;
  let positionsIndex = 0;
  let normalsIndex = 0;
  let colorsIndex = 0;
  let uvsIndex = 0;

  const globalMaterial = new THREE.MeshStandardMaterial({
    color: 0xFFFFFF,
    vertexColors: true,
    transparent: true,
    alphaTest: 0.5,
  });
  const _makeMesh = () => {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(NUM_POSITIONS*3);
    positionsIndex = 0;
    const positionsAttribute = new THREE.BufferAttribute(positions, 3);
    geometry.setAttribute('position', positionsAttribute);
    const normals = new Float32Array(NUM_POSITIONS*3);
    normalsIndex = 0;
    const normalsAttribute = new THREE.BufferAttribute(normals, 3);
    geometry.setAttribute('normal', normalsAttribute);
    const colors = new Float32Array(NUM_POSITIONS*3);
    colorsIndex = 0;
    const colorsAttribute = new THREE.BufferAttribute(colors, 3);
    geometry.setAttribute('color', colorsAttribute);
    const uvs = new Float32Array(NUM_POSITIONS*2);
    uvsIndex = 0;
    const uvsAttribute = new THREE.BufferAttribute(uvs, 2);
    geometry.setAttribute('uv', uvsAttribute);
    /* const index = new Uint16Array(NUM_POSITIONS*3);
    let indexIndex = 0;
    const indexAttribute = new THREE.BufferAttribute(index, 1);
    geometry.setIndex(indexAttribute); */
    geometry.setDrawRange(0, 0);

    // window.colorsAttribute = geometry;

    const mesh = new THREE.Mesh(geometry, globalMaterial);
    mesh.frustumCulled = false;
    container.add(mesh);
    currentMesh = mesh;
    atlas = atlaspack(1024, 1024);
    atlas.images = [];
    atlas.nodes = [];

    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, 256, 256);
    _pushAtlasImage(canvas, 0, 0);
  };
  const _pushAtlasImage = (image, offset, count) => {
    for (;;) {
      const {width, height} = image;
      const node = atlas.pack({width, height});
      if (node) {
        node.image = image;
        node.offset = offset;
        node.count = count;
        atlas.images.push(image);
        atlas.nodes.push(node);
        break;
      } else {
        const oldAtlas = atlas;
        atlas = atlaspack(atlas.rect.w*2, atlas.rect.w*2);
        atlas.images = [];
        atlas.nodes = [];
        for (let i = 0; i < oldAtlas.nodes.length; i++) {
          const oldNode = oldAtlas.nodes[i];
          const {image, offset, count} = oldNode;
          const {width, height} = image;
          const node = atlas.pack({width, height});
          node.image = image;
          node.offset = offset;
          node.count = count;
          atlas.images.push(image);
          atlas.nodes.push(node);
        }
        continue;
      }
    }
  };
  const _mergeMesh = o => {
    if (!currentMesh || (positionsIndex + o.geometry.attributes.position.array.length) >= currentMesh.geometry.attributes.position.array.length) {
      _makeMesh();
    }
    const {geometry, material} = currentMesh;
    const positionsAttribute = geometry.attributes.position;
    const positions = positionsAttribute.array;
    const normalsAttribute = geometry.attributes.normal;
    const normals = normalsAttribute.array;
    const colorsAttribute = geometry.attributes.color;
    const colors = colorsAttribute.array;
    const uvsAttribute = geometry.attributes.uv;
    const uvs = uvsAttribute.array;

    o.updateMatrixWorld();

    if (o.geometry.index) {
      o.geometry = o.geometry.toNonIndexed();
    }
    if (!Array.isArray(o.material) && o.material.map && o.geometry.attributes.uv) {
      /* if (!globalMaterial.map) {
        globalMaterial.map = new THREE.DataTexture(Uint8Array.from([255, 255, 255, 255]), 1, 1, THREE.RGBAFormat, THREE.UnsignedByteType, THREE.UVMapping);
        // globalMaterial.map = new THREE.Texture(o.material.map.image);
      } */

      _pushAtlasImage(o.material.map.image, uvsIndex, o.geometry.attributes.uv.array.length);
    }

    new Float32Array(positions.buffer, positions.byteOffset + positionsIndex*Float32Array.BYTES_PER_ELEMENT, o.geometry.attributes.position.array.length)
      .set(o.geometry.attributes.position.array);
    positionsAttribute.updateRange.offset = positionsIndex;
    positionsAttribute.updateRange.count = o.geometry.attributes.position.array.length;
    positionsIndex += o.geometry.attributes.position.array.length;

    new Float32Array(normals.buffer, normals.byteOffset + normalsIndex*Float32Array.BYTES_PER_ELEMENT, o.geometry.attributes.normal.array.length)
      .set(o.geometry.attributes.normal.array);
    normalsAttribute.updateRange.offset = normalsIndex;
    normalsAttribute.updateRange.count = o.geometry.attributes.normal.array.length;
    normalsIndex += o.geometry.attributes.normal.array.length;

    colorsAttribute.updateRange.offset = colorsIndex;
    colorsAttribute.updateRange.count = o.geometry.attributes.position.array.length;
    if (o.geometry.groups.length > 0) {
      for (let i = 0; i < o.geometry.groups.length; i++) {
        const group = o.geometry.groups[i];
        const {start, count, materialIndex} = group;
        const material = o.material[materialIndex];
        for (let j = start; j < start + count; j++) {
          colors[colorsIndex + j*3] = material.color.r;
          colors[colorsIndex + j*3 + 1] = material.color.g;
          colors[colorsIndex + j*3 + 2] = material.color.b;
        }
      }
      colorsIndex += o.geometry.attributes.position.array.length;
    } else {
      const material = Array.isArray(o.material) ? o.material[0] : o.material;
      for (let i = 0; i < o.geometry.attributes.position.array.length; i += 3) {
        colors[colorsIndex++] = material.color.r;
        colors[colorsIndex++] = material.color.g;
        colors[colorsIndex++] = material.color.b;
      }
    }

    if (o.geometry.attributes.uv) {
      new Float32Array(uvs.buffer, uvs.byteOffset + uvsIndex*Float32Array.BYTES_PER_ELEMENT, o.geometry.attributes.uv.array.length)
        .set(o.geometry.attributes.uv.array);
      uvsAttribute.updateRange.offset = uvsIndex;
      uvsAttribute.updateRange.count = o.geometry.attributes.uv.array.length;
      uvsIndex += o.geometry.attributes.uv.array.length;
    } else {
      uvsIndex += o.geometry.attributes.position.array.length/3*2;
    }

    positionsAttribute.needsUpdate = true;
    renderer.attributes.update(positionsAttribute, 34962);
    normalsAttribute.needsUpdate = true;
    renderer.attributes.update(normalsAttribute, 34962);
    colorsAttribute.needsUpdate = true;
    renderer.attributes.update(colorsAttribute, 34962);
    uvsAttribute.needsUpdate = true;
    renderer.attributes.update(uvsAttribute, 34962);
    geometry.setDrawRange(0, positionsIndex/3);
  };

  const objs = modelFiles.filter(m => /\.obj/.test(m));
  // console.log('objs', objs);
  const manager = new THREE.LoadingManager();
  const rowSize = 10;
  const numItems = 10;
  for (let i = 0; i < numItems; i++) {
    console.log(i);
    const u = `models/${objs[i]}`;

    const p = makePromise();
    new MTLLoader(manager)
      // .setPath( '/' )
      .load(u.replace('.obj', '.mtl'), materials => {
        materials.preload();
        p.accept(materials);
        // materials.preload();
      });
    let materials = await p;
    materials = Object.keys(materials.materials).map(k => materials.materials[k]);

    /* new OBJLoader( manager )
      .setMaterials( materials )
      .setPath( 'models/obj/male02/' )
      .load( 'male02.obj', function ( object ) {
        object.position.y = - 95;
        scene.add( object );
      }, onProgress, onError ); */
    
    const p2 = makePromise();
    const loader = new OBJLoader2(manager);
    // window.loader = loader;
    loader.parser.setMaterials( materials );
    loader.load(u, p2.accept, function onProgress() {}, p2.reject);

    const x = i%rowSize;
    const z = -Math.floor(i/rowSize);

    const o = await p2;
    o.traverse(o => {
      if (o.isMesh) {
        // o.material = materials;
        // o.material = material;
        o.geometry
          .applyMatrix4(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI)))
          .applyMatrix4(new THREE.Matrix4().makeTranslation(-rowSize/2 + x, 0, z));
        o.material = materials;
        _mergeMesh(o);
      }
    });

    // window.materials.push(materials);
    // console.log('got materials', o, materials);
  }

  const p3 = makePromise();
  new GLTFLoader(manager).load('models/model.vrm', p3.accept, function onProgress() {}, p3.reject);
  const o = await p3;
  console.log('got model', o.scene);
  // container.add(o.scene);

  o.scene.traverse(o => {
    if (o.isMesh) {
      _mergeMesh(o);
    }
  });

  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 1024;
  const scale = atlas.rect.w/canvas.width;
  const ctx = canvas.getContext('2d');
  // ctx.translate(0, canvas.height);
  // ctx.scale(1, -1);
  for (let i = 0; i < atlas.nodes.length; i++) {
    const node = atlas.nodes[i];
    const {rect: {x, y, w, h}, image, offset, count} = node;
    ctx.drawImage(image, x/scale, y/scale, w/scale, h/scale);

    for (let i = 0; i < count; i += 2) {
      let u = currentMesh.geometry.attributes.uv.array[offset + i];
      let v = currentMesh.geometry.attributes.uv.array[offset + i + 1];
      u = Math.min(Math.max(u, 0), 1);
      v = Math.min(Math.max(v, 0), 1);
      u = (x+scale + u*(w-scale*2))/atlas.rect.w;
      v = (y+scale + v*(h-scale*2))/atlas.rect.h;
      currentMesh.geometry.attributes.uv.array[offset + i] = u;
      currentMesh.geometry.attributes.uv.array[offset + i + 1] = v;

      // console.log('setting', offset + i, oldU, u, x, w, atlas.rect.w);
    }
  }
  currentMesh.geometry.attributes.uv.updateRange.offset = 0;
  currentMesh.geometry.attributes.uv.updateRange.count = -1;
  currentMesh.geometry.attributes.uv.needsUpdate = true;
  globalMaterial.map = new THREE.Texture(canvas);
  globalMaterial.map.generateMipmaps = false;
  globalMaterial.map.wrapS = globalMaterial.map.wrapT = THREE.ClampToEdgeWrapping; // THREE.RepeatWrapping;
  globalMaterial.map.minFilter = THREE.LinearFilter;
  globalMaterial.map.flipY = false;
  globalMaterial.map.needsUpdate = true;
  globalMaterial.needsUpdate = true;
  // document.body.appendChild(canvas);

  // console.log('got atlas', atlas);
  // window.geometry = currentMesh.geometry;

  // container.remove(o.scene);

  // return;
  const positions = new Float32Array(currentMesh.geometry.attributes.position.array.buffer, currentMesh.geometry.attributes.position.array.byteOffset, currentMesh.geometry.drawRange.count*3);
  const normals = new Float32Array(currentMesh.geometry.attributes.normal.array.buffer, currentMesh.geometry.attributes.normal.array.byteOffset, currentMesh.geometry.drawRange.count*3);
  const colors = new Float32Array(currentMesh.geometry.attributes.color.array.buffer, currentMesh.geometry.attributes.color.array.byteOffset, currentMesh.geometry.drawRange.count*3);
  const mins = [-2, 0, -2];
  const maxs = [2, 0, 2];
  const scales = [1, 1, 1];
  const arrayBuffer = new ArrayBuffer(8 * 1024 * 1024);
  worker.request({
    method: 'chunk',
    positions,
    normals,
    colors,
    mins,
    maxs,
    scales,
    arrayBuffer,
  }, [arrayBuffer]).then(res => {
    console.log('got res', res);

    container.remove(currentMesh);
    currentMesh = null;

    let i = 0;
    for (let x = mins[0]; x < maxs[0]; x++) {
      for (let z = mins[2]; z < maxs[2]; z++) {
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(res.positions[i], 3));
        geometry.setAttribute('normal', new THREE.BufferAttribute(res.normals[i], 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(res.colors[i], 3));

        // window.colorsAttribute = geometry;

        const mesh = new THREE.Mesh(geometry, globalMaterial);
        mesh.frustumCulled = false;
        meshes.push(mesh);
        container.add(mesh);

        mesh.x = x;
        mesh.z = z;

        i++;
      }
    }
  });
})();

function animate() {
  orbitControls.enabled && orbitControls.update();

  const f = (Math.sin((Date.now()%1000)/1000*Math.PI*2)+1)/2*0.3;
  for (let i = 0; i < meshes.length; i++) {
    const mesh = meshes[i];
    mesh.position.set(mesh.x*f, 0, mesh.z*f);
  }
  
  /* if (currentSession) {
    for (let i = 0; i < 2; i++) {
      const controller = renderer.xr.getController(i);
      if (controller.userData.data) {
        if (controller.userData.data.handedness === 'left') {
          uiMesh.position.copy(controller.position);
          uiMesh.quaternion.copy(controller.quaternion);
        } else if (controller.userData.data.handedness === 'right') {
          _updateRaycasterFromObject(localRaycaster, controller);
          _updateTool(localRaycaster);
        }
      }
    }

    _updateControllers();

    updatePlayerFromXr(renderer.xr, camera);
  } else {
    const speed = 0.015 * (keys.shift ? 3 : 1);
    const cameraEuler = camera.rotation.clone();
    cameraEuler.x = 0;
    cameraEuler.z = 0;
    const extraVelocity = new THREE.Vector3();
    if (keys.left) {
      extraVelocity.add(new THREE.Vector3(-1, 0, 0).applyEuler(cameraEuler));
    }
    if (keys.right) {
      extraVelocity.add(new THREE.Vector3(1, 0, 0).applyEuler(cameraEuler));
    }
    if (keys.up) {
      extraVelocity.add(new THREE.Vector3(0, 0, -1).applyEuler(cameraEuler));
    }
    if (keys.down) {
      extraVelocity.add(new THREE.Vector3(0, 0, 1).applyEuler(cameraEuler));
    }
    if (extraVelocity.length() > 0) {
      extraVelocity.normalize().multiplyScalar(speed);
    }
    velocity.add(extraVelocity);
    camera.position.add(velocity);
    velocity.multiplyScalar(0.7);
    
    orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5).applyQuaternion(camera.quaternion));
    
    updatePlayerFromCamera(camera);
  }

  for (let i = 0; i < peerConnections.length; i++) {
    const peerConnection = peerConnections[i];
    peerConnection.rig && peerConnection.rig.update();
  }

  tickObjectScript(objectState);

  if (ammo) {
    ammo.simulate();
    for (let i = 0; i < objectMeshes.length; i++) {
      ammo.updateObjectMesh(objectMeshes[i]);
    }
  } */

  /* const thirdperson = selectedTool === 'thirdperson';
  let oldCameraPosition;
  if (thirdperson) {
    oldCameraPosition = camera.position.clone();
    camera.position.add(new THREE.Vector3(0, 0, 2).applyQuaternion(camera.quaternion));
  } */
  renderer.render(scene, camera);
  /* if (thirdperson) {
    camera.position.copy(oldCameraPosition);
  } */
}
renderer.setAnimationLoop(animate);

window.addEventListener('resize', e => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
  </body>
</html>