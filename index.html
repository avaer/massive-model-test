<!doctype html>
<html>
  <head>
    <link rel=icon type="image/png" href="favicon.png">
    <meta name="twitter:image:src" content="https://metacomposer.com/logo.svg">
    <meta name="twitter:site" content="@exokitxr">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Metacomposer">
    <meta name="twitter:description" content="Meta composer">
    <meta property="og:title" content="Metacomposer">
    <meta property="og:type" content="referenceSpace">
    <meta property="og:url" content="https://metacomposer.com/">
    <meta property="og:image" content="https://metacomposer.com/logo.svg">
    <link href="index.css" rel=stylesheet>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/0735724151.js" crossorigin="anonymous"></script>
    <!-- <script type="module" src="world.js"></script> -->
  </head>
  <body>
    <header>
      <!-- <a href="https://browser.exokit.org">
        <img class=icon src="logo.svg"/>
      </a> -->
      <a href="/" class="nav open" id="explore-dropdown">Test</a>
      <!-- <a href="/world.html" class="nav" id="explore-dropdown">Atlas</a>
      <a href="/create.html" class="nav" id="explore-dropdown">Create</a>
      <a href="/gallery.html" class="nav" id="explore-dropdown">Gallery</a> -->
    </header>
    <canvas id=canvas></canvas>
<script type=module>
import THREE from './three.module.js';
import {OrbitControls} from './OrbitControls.js';
import {GLTFLoader} from './GLTFLoader.js';
import {LegacyGLTFLoader} from './LegacyGLTFLoader.js';
import {OBJLoader2} from './OBJLoader2.js';
import {MTLLoader} from './MTLLoader.js';
import {Mesher, makeGlobalMaterial, makeTexture, CHUNK_SIZE} from './mesher.js';
import modelFiles from './model-files.js';

function makePromise() {
  let accept, reject;
  const p = new Promise((a, r) => {
    accept = a;
    reject = r;
  });
  p.accept = accept;
  p.reject = reject;
  return p;
}

const canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true,
});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
renderer.physicallyCorrectLights = true;
// renderer.shadowMap.enabled = true;
// renderer.shadowMap.type = THREE.PCFShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0.5, 1.5);
camera.rotation.order = 'YXZ';
renderer.render(scene, camera);

// window.renderer = renderer;

const ambientLight = new THREE.AmbientLight(0xFFFFFF);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight.position.set(0.5, 1, 0.5).multiplyScalar(100);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.camera.near = 0.5;
directionalLight.shadow.camera.far = 500;
scene.add(directionalLight);

const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 3);
directionalLight2.position.set(-0.5, -0.1, 0.5).multiplyScalar(100);
scene.add(directionalLight2);

const container = new THREE.Object3D();
scene.add(container);

const orbitControls = new OrbitControls(camera, renderer.domElement, document);
orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5));
orbitControls.screenSpacePanning = true;
// orbitControls.enabled = !!loginToken;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

function mod(a, n) {
  return ((a%n)+n)%n;
}
const distanceFactor = 64;
const parcelSize = 16;
const parcelGeometry = (() => {
  const tileGeometry = new THREE.PlaneBufferGeometry(1, 1)
    .applyMatrix4(new THREE.Matrix4().makeScale(0.95, 0.95, 1))
    .applyMatrix4(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2)))
    .toNonIndexed();
  const numCoords = tileGeometry.attributes.position.array.length;
  const numVerts = numCoords/3;
  const positions = new Float32Array(numCoords*parcelSize*parcelSize);
  const centers = new Float32Array(numCoords*parcelSize*parcelSize);
  const typesx = new Float32Array(numVerts*parcelSize*parcelSize);
  const typesz = new Float32Array(numVerts*parcelSize*parcelSize);
  let i = 0;
  for (let x = -parcelSize/2+0.5; x < parcelSize/2; x++) {
    for (let z = -parcelSize/2+0.5; z < parcelSize/2; z++) {
      const newTileGeometry = tileGeometry.clone()
        .applyMatrix4(new THREE.Matrix4().makeTranslation(x, 0, z));
      positions.set(newTileGeometry.attributes.position.array, i * newTileGeometry.attributes.position.array.length);
      for (let j = 0; j < newTileGeometry.attributes.position.array.length/3; j++) {
        new THREE.Vector3(x, 0, z).toArray(centers, i*newTileGeometry.attributes.position.array.length + j*3);
      }
      let typex = 0;
      if (mod((x + parcelSize/2-0.5), parcelSize) === 0) {
        typex = 1/8;
      } else if (mod((x + parcelSize/2-0.5), parcelSize) === parcelSize-1) {
        typex = 2/8;
      }
      let typez = 0;
      if (mod((z + parcelSize/2-0.5), parcelSize) === 0) {
        typez = 1/8;
      } else if (mod((z + parcelSize/2-0.5), parcelSize) === parcelSize-1) {
        typez = 2/8;
      }
      for (let j = 0; j < numVerts; j++) {
        typesx[i*numVerts + j] = typex;
        typesz[i*numVerts + j] = typez;
      }
      i++;
    }
  }
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('center', new THREE.BufferAttribute(centers, 3));
  geometry.setAttribute('typex', new THREE.BufferAttribute(typesx, 1));
  geometry.setAttribute('typez', new THREE.BufferAttribute(typesz, 1));
  return geometry;
})();
const floorVsh = `
  #define PI 3.1415926535897932384626433832795

  uniform vec3 uPosition;
  uniform float uAnimation;
  uniform vec4 uSelectedParcel;
  attribute vec3 center;
  attribute float typex;
  attribute float typez;
  varying vec3 vPosition;
  varying float vTypex;
  varying float vTypez;
  varying float vDepth;
  varying float vPulse;

  float range = 1.0;

  void main() {
    float height;
    vec3 c = center + uPosition;
    float selectedWidth = uSelectedParcel.z - uSelectedParcel.x;
    float selectedHeight = uSelectedParcel.w - uSelectedParcel.y;
    if (c.x >= uSelectedParcel.x && c.x < uSelectedParcel.z && c.z >= uSelectedParcel.y && c.z < uSelectedParcel.w) {
      vec2 selectedCenter = vec2((uSelectedParcel.x+uSelectedParcel.z) / 2.0, (uSelectedParcel.y+uSelectedParcel.w) / 2.0);
      float selectedSize = max(selectedWidth, selectedHeight)/2.0;
      float selectedRadius = sqrt(selectedSize*selectedSize+selectedSize*selectedSize);

      float animationRadius = uAnimation * selectedRadius;
      float currentRadius = length(c.xz - selectedCenter);
      float radiusDiff = abs(animationRadius - currentRadius);
      height = max((range - radiusDiff)/range, 0.0);
      height = sin(height*PI/2.0);
      height *= 0.2;

      vPulse = 1.0 + (1.0 - mod(uAnimation * 2.0, 1.0)/2.0) * 0.5;
    } else {
      vPulse = 1.0;
    }
    vec3 p = vec3(position.x, position.y + height, position.z);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
    vPosition = position;
    vTypex = typex;
    vTypez = typez;
    vDepth = gl_Position.z / ${distanceFactor.toFixed(8)};
  }
`;
const floorFsh = `
  #define PI 3.1415926535897932384626433832795

  uniform vec3 uColor;
  uniform float uHover;
  uniform float uAnimation;
  varying vec3 vPosition;
  varying float vTypex;
  varying float vTypez;
  varying float vDepth;
  varying float vPulse;

  void main() {
    float add = uHover * 0.2;
    vec3 f = fract(vPosition);
    if (vTypex >= 2.0/8.0) {
      if (f.x >= 0.8) {
        add = 0.2;
      }
    } else if (vTypex >= 1.0/8.0) {
      if (f.x <= 0.2) {
        add = 0.2;
      }
    }
    if (vTypez >= 2.0/8.0) {
      if (f.z >= 0.8) {
        add = 0.2;
      }
    } else if (vTypez >= 1.0/8.0) {
      if (f.z <= 0.2) {
        add = 0.2;
      }
    }
    vec3 c = (uColor + add) * vPulse;
    float a = (1.0-vDepth)*0.8;
    gl_FragColor = vec4(c, a);
  }
`;
const _makeFloorMesh = (x, z) => {
  const geometry = parcelGeometry;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      uPosition: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uColor: {
        type: 'c',
        value: new THREE.Color().setHex(0x333333),
      },
      uHover: {
        type: 'f',
        value: 0,
      },
      uSelectedParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: floorVsh,
    fragmentShader: floorFsh,
    side: THREE.DoubleSide,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  // mesh.position.set(x*parcelSize, 0, z*parcelSize);
  // mesh.material.uniforms.uPosition.value.copy(mesh.position);
  mesh.frustumCulled = false;
  /* mesh.update = () => {
    const xrSite = _getFloorMeshXrSite(mesh);
    const color = _getSelectedColor(xrSite);
    material.uniforms.uColor.value.setHex(color);
  }; */
  return mesh;
};
const floorMesh = _makeFloorMesh();
container.add(floorMesh);

const mesher = new Mesher(renderer);
// container.add(mesher.currentMesh);
let meshes = [];
(async () => {
  const manager = new THREE.LoadingManager();

  /* {
    const objs = modelFiles.filter(m => /\.obj/.test(m));
    const rowSize = 10;
    const numItems = 10;
    for (let i = 0; i < numItems; i++) {
      console.log(i);
      const u = `models/${objs[i]}`;

      const p = makePromise();
      new MTLLoader(manager)
        .load(u.replace('.obj', '.mtl'), materials => {
          materials.preload();
          p.accept(materials);
        });
      let materials = await p;
      materials = Object.keys(materials.materials).map(k => materials.materials[k]);
      
      const p2 = makePromise();
      const loader = new OBJLoader2(manager);
      loader.parser.setMaterials( materials );
      loader.load(u, p2.accept, function onProgress() {}, p2.reject);

      const x = i%rowSize;
      const z = -Math.floor(i/rowSize);

      const o = await p2;
      o.traverse(o => {
        if (o.isMesh) {
          o.geometry
            .applyMatrix4(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI)))
            .applyMatrix4(new THREE.Matrix4().makeTranslation(-rowSize/2 + x, 0, z));
          o.material = materials;
          mesher.addMesh(o);
        }
      });
      // container.add(o);
    }
  } */

  {
    const p = makePromise();
    new GLTFLoader(manager).load('models/mountain.glb', p.accept, function onProgress() {}, p.reject);
    const o = await p;
    mesher.addMesh(o.scene);
  }

  {
    const p = makePromise();
    new GLTFLoader(manager).load('models/building.glb', p.accept, function onProgress() {}, p.reject);
    const o = await p;
    mesher.addMesh(o.scene);
  }

  {
    const p = makePromise();
    new GLTFLoader(manager).load('models/model.vrm', p.accept, function onProgress() {}, p.reject);
    const o = await p;
    mesher.addMesh(o.scene);
  }

  /* {
    const p = makePromise();
    new LegacyGLTFLoader(manager).load('models/dino/sketch.gltf', p.accept, function onProgress() {}, p.reject);
    const o = await p;
    mesher.addMesh(o.scene);
  } */

  /* {
    const p = makePromise();
    new GLTFLoader(manager).load('models/scene.glb', p.accept, function onProgress() {}, p.reject);
    const o = await p;

    // window.o = o;
    // o.scene.children.splice(40, Infinity);
    // const chair = o.scene.children.slice(29, 30);
    // o.scene.children.length = 0;
    // o.scene.children.push.apply(o.scene.children, chair);
    _mergeScene(o.scene);

    // container.add(o.scene);
  } */

  const _getMeshUrl = (x, z) => `/d/chunk:${x}:${z}.bin`;
  const _serializeMesh = async mesh => {
    const positions = mesh.geometry.attributes.position.array;
    const normals = mesh.geometry.attributes.normal.array;
    const colors = mesh.geometry.attributes.color.array;
    const uvs = mesh.geometry.attributes.uv.array;
    const ids = mesh.geometry.attributes.id.array;
    const texData = await new Promise((accept, reject) => {
      mesh.material.map.image.toBlob(b => {
        const rs = new FileReader();
        rs.onload = () => accept(new Uint8Array(rs.result));
        rs.onerror = reject;
        rs.readAsArrayBuffer(b);
      });
    });

    const arrayBuffer = new ArrayBuffer(
      Uint32Array.BYTES_PER_ELEMENT +
      positions.length*Float32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      normals.length*Float32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      colors.length*Float32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      uvs.length*Float32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      ids.length*Uint32Array.BYTES_PER_ELEMENT +
      Uint32Array.BYTES_PER_ELEMENT +
      texData.length
    );

    let index = 0;
    const _set = o => {
      new Uint32Array(arrayBuffer, index, 1)[0] = o.length;
      index += Uint32Array.BYTES_PER_ELEMENT;
      new o.constructor(arrayBuffer, index, o.length).set(o);
      index += o.length*o.constructor.BYTES_PER_ELEMENT;
    };
    _set(positions);
    _set(normals);
    _set(colors);
    _set(uvs);
    _set(ids);
    _set(texData);

    return arrayBuffer;
  };
  const _deserializeMesh = async arrayBuffer => {
    let index = 0;
    const _get = c => {
      const count = new Uint32Array(arrayBuffer, index, 1)[0];
      index += Uint32Array.BYTES_PER_ELEMENT;
      const o = new c(arrayBuffer, index, count);
      index += count*c.BYTES_PER_ELEMENT;
      return o;
    };
    const positions = _get(Float32Array);
    const normals = _get(Float32Array);
    const colors = _get(Float32Array);
    const uvs = _get(Float32Array);
    const ids = _get(Uint32Array);
    const texData = _get(Uint8Array);

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    geometry.setAttribute('id', new THREE.BufferAttribute(ids, 1));

    const material = makeGlobalMaterial();
    const img = await new Promise((accept, reject) => {
      const img = new Image();
      const u = URL.createObjectURL(new Blob([texData], {
        type: 'image/png',
      }));
      img.src = u;
      img.onload = () => {
        URL.revokeObjectURL(u);
        accept(img);
      };
      img.onerror = err => {
        URL.revokeObjectURL(u);
        reject(err);
      };
    });
    material.map = makeTexture(img);

    const mesh = new THREE.Mesh(geometry, material);
    mesh.frustumCulled = false;
    return mesh;
  };

  /* meshes = await (async () => {
    const result = [];
    for (let x = -1; x < 1; x++) {
      for (let z = -1; z < 1; z++) {
        const res = await fetch(_getMeshUrl(x, z));
        const arrayBuffer = await res.arrayBuffer();
        const mesh = await _deserializeMesh(arrayBuffer);
        meshes.push(mesh);
      }
    }
    return result;
  })(); */

  const voxelWidth = 10;
  const voxelSize = 1;
  const pixelRatio = 3;
  mesher.initVoxelize(voxelWidth, voxelSize, pixelRatio);

  // const lodBaseChunk = new THREE.Vector3(Math.floor(currentPos.x/voxelSize), Math.floor(currentPos.y/voxelSize), Math.floor(currentPos.z/voxelSize));
  /* const lods = [
    {
      x: lodBaseChunk.x,
      z: lodBaseChunk.z,
      lod: 0,
    },
    {
      x: lodBaseChunk.x + voxelSize,
      z: lodBaseChunk.z,
      lod: 0,
    },
    {
      x: lodBaseChunk.x,
      z: lodBaseChunk.z + voxelSize,
      lod: 0,
    },
    {
      x: lodBaseChunk.x + voxelSize,
      z: lodBaseChunk.z + voxelSize,
      lod: 0,
    },
  ]; */
  const currentPos = new THREE.Vector3(0, 0, 0);
  const lods = [];
  let offset = 0;
  // for (let lod = 0; lod < 2; lod++) {
    let lod = 0;
    const lodVoxelSize = voxelSize * (3**lod);
    const lodBaseChunk = new THREE.Vector3(Math.floor(currentPos.x/lodVoxelSize), Math.floor(currentPos.y/lodVoxelSize), Math.floor(currentPos.z/lodVoxelSize));
    for (let x = -2; x <= 4; x++) {
      for (let z = -3; z <= 3; z++) {
        for (let y = -3; y <= 3; y++) {
          if (lod === 0 || x !== 0 || y !== 0 || z !== 0) {
            lods.push({
              x: lodBaseChunk.x + x,
              y: lodBaseChunk.y + y,
              z: lodBaseChunk.z + z,
              offset,
              lod,
            });
          }
        }
      }
    }
    offset -= lodVoxelSize;
  // }
    
    
  for (let i = 0; i < lods.length; i++) {
    const {x, y, z, offset, lod} = lods[i];
    const mesh = await mesher.getChunk(x, y, z, offset, offset, offset, lod);
    // console.log('got chunk', x, y, z, mesh.geometry.attributes.position.array.length);
    container.add(mesh);
    meshes.push(mesh);
  }
  // }
  /* const _testMesh = async m => {
    const ab = await _serializeMesh(m);
    const m2 = await _deserializeMesh(ab);
    m2.x = m.x;
    m2.z = m.z;
    return m2;
  };
  meshes = await Promise.all(meshes.map(m => _testMesh(m))); */
  return;

  {
    for (let i = 0; i < meshes.length; i++) {
      const mesh = meshes[i];
      const body = await _serializeMesh(mesh);
      console.log('set body', mesh.x, mesh.z, body);
      const res = await fetch(_getMeshUrl(x, z), {
        method: 'PUT',
        body,
      });
      if (!res.ok) {
        throw new Error(`got invalid status code: ${res.status}`);
      }
    }
  }
})();

function animate() {
  orbitControls.enabled && orbitControls.update();

  /* const f = (Math.sin((Date.now()%1000)/1000*Math.PI*2)+1)/2*0.3;
  for (let i = 0; i < meshes.length; i++) {
    const mesh = meshes[i];
    mesh.position.set(mesh.x*f, 0, mesh.z*f);
  } */
  
  /* if (currentSession) {
    for (let i = 0; i < 2; i++) {
      const controller = renderer.xr.getController(i);
      if (controller.userData.data) {
        if (controller.userData.data.handedness === 'left') {
          uiMesh.position.copy(controller.position);
          uiMesh.quaternion.copy(controller.quaternion);
        } else if (controller.userData.data.handedness === 'right') {
          _updateRaycasterFromObject(localRaycaster, controller);
          _updateTool(localRaycaster);
        }
      }
    }

    _updateControllers();

    updatePlayerFromXr(renderer.xr, camera);
  } else {
    const speed = 0.015 * (keys.shift ? 3 : 1);
    const cameraEuler = camera.rotation.clone();
    cameraEuler.x = 0;
    cameraEuler.z = 0;
    const extraVelocity = new THREE.Vector3();
    if (keys.left) {
      extraVelocity.add(new THREE.Vector3(-1, 0, 0).applyEuler(cameraEuler));
    }
    if (keys.right) {
      extraVelocity.add(new THREE.Vector3(1, 0, 0).applyEuler(cameraEuler));
    }
    if (keys.up) {
      extraVelocity.add(new THREE.Vector3(0, 0, -1).applyEuler(cameraEuler));
    }
    if (keys.down) {
      extraVelocity.add(new THREE.Vector3(0, 0, 1).applyEuler(cameraEuler));
    }
    if (extraVelocity.length() > 0) {
      extraVelocity.normalize().multiplyScalar(speed);
    }
    velocity.add(extraVelocity);
    camera.position.add(velocity);
    velocity.multiplyScalar(0.7);
    
    orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1.5).applyQuaternion(camera.quaternion));
    
    updatePlayerFromCamera(camera);
  }

  for (let i = 0; i < peerConnections.length; i++) {
    const peerConnection = peerConnections[i];
    peerConnection.rig && peerConnection.rig.update();
  }

  tickObjectScript(objectState);

  if (ammo) {
    ammo.simulate();
    for (let i = 0; i < objectMeshes.length; i++) {
      ammo.updateObjectMesh(objectMeshes[i]);
    }
  } */

  /* const thirdperson = selectedTool === 'thirdperson';
  let oldCameraPosition;
  if (thirdperson) {
    oldCameraPosition = camera.position.clone();
    camera.position.add(new THREE.Vector3(0, 0, 2).applyQuaternion(camera.quaternion));
  } */
  renderer.render(scene, camera);
  /* if (thirdperson) {
    camera.position.copy(oldCameraPosition);
  } */
}
renderer.setAnimationLoop(animate);

window.addEventListener('resize', e => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
  </body>
</html>